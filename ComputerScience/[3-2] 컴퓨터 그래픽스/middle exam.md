# 컴퓨터그래픽스 시험 대비 자료

## 📚 목차
- [[#OpenGL 기본 구조]]
- [[#좌표계와 투영 (Projection)]]
- [[#종횡비 (Aspect Ratio) 문제]]
- [[#기본 도형 그리기]]
- [[#주요 함수 정리]]

---

## OpenGL 기본 구조

OpenGL과 GLUT 기반 프로그램은 **초기화 → 콜백 등록 → 이벤트 루프**의 패턴으로 움직입니다. 시험에서는 이 흐름을 서술형으로 묻거나, 특정 단계가 빠졌을 때 어떤 문제가 생기는지 확인하는 문제가 자주 나옵니다. 아래 코드는 모든 실습의 공통 뼈대이므로, 각 호출의 역할을 이해한 뒤 나만의 언어로 재구성해 볼 필요가 있습니다.

> ✅ **암기 포인트**: `glutMainLoop` 이전에는 "준비 단계", 이후에는 OS 이벤트에 따라 등록해 둔 함수가 반복 호출된다.

### ==필수 초기화 과정==

```cpp
int main(int argc, char** argv) {
    glutInit(&argc, argv);                    // **GLUT 초기화**
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);  // **디스플레이 모드 설정**
    glutInitWindowSize(640, 480);             // 창 크기 설정
    glutInitWindowPosition(500, 500);         // 창 위치 설정
    glutCreateWindow("Window Title");         // 창 생성

    glutDisplayFunc(RenderScene);             // **디스플레이 콜백**
    glutReshapeFunc(ChangeSize);              // **리사이즈 콜백**

    glutMainLoop();                           // **이벤트 루프 시작**
    return 0;
}
```

**코드 위치**: 모든 실습 파일의 main 함수 참조

- `glutInit`은 GLUT 내부 상태를 초기화하며, **항상 main의 첫 줄**에서 호출한다.
- `glutInitDisplayMode`의 플래그 조합은 **프레임 버퍼 구성**을 결정한다. 예: `GLUT_DOUBLE`을 추가하면 이중 버퍼링이 가능.
- 창 크기와 위치는 OS가 창을 띄울 때 참고하는 값으로, **추후 ChangeSize 콜백에서 다시 조정하더라도 초기값**을 전달해 주어야 한다.
- 콜백 등록(`glutDisplayFunc`, `glutReshapeFunc`)을 빼먹으면 이벤트가 발생해도 아무 렌더링이 일어나지 않는다.
- `glutMainLoop` 이후에는 코드가 돌아오지 않으므로, **리소스 해제나 초기 그리기 설정은 그 이전에 끝내야 한다.**

### ==핵심 콜백 함수==

콜백은 운영체제(OS) 이벤트에 반응하도록 설계된 함수입니다. 시험에서는 "디스플레이 콜백이 언제 호출되는가?", "ChangeSize에서 Projection 행렬을 초기화하지 않으면 어떤 현상이 생기는가?" 같은 질문이 잘 나옵니다. 아래 예시 코드와 함께 흐름을 이해하십시오.

#### 1. **RenderScene()** - 화면 렌더링
```cpp
void RenderScene(void) {
    glClear(GL_COLOR_BUFFER_BIT);   // ==화면 지우기 (필수)==

    // 그리기 코드
    glColor3f(1.0f, 0.0f, 0.0f);    // 색상 설정 (R, G, B)
    glBegin(GL_POINTS);              // 기본 도형 시작
        glVertex3f(x, y, z);         // 정점 지정
    glEnd();                         // 기본 도형 끝

    glFlush();                       // ==명령 즉시 실행==
}
```

**코드 위치**: code/3-1.cpp:14-26

- `glClear`는 렌더링 결과가 겹치는 현상을 방지하므로 **모든 프레임의 첫 줄**에 두는 습관을 들인다.
- `glBegin` ~ `glEnd` 블록에 들어가는 정점은 **현재 지정한 색상·두께** 속성을 공유한다.
- `glFlush`는 명령을 GPU 큐로 즉시 밀어 넣으며, **단일 버퍼(GLUT_SINGLE)** 에서 결과를 바로 보고 싶을 때 필요하다.
- 이중 버퍼를 사용하는 경우 `glutSwapBuffers()`를 호출해야 하며, 시험에서 "깜빡임(flickering) 원인"으로 연결되는 단골 소재다.

#### 2. **ChangeSize()** - 창 크기 변경 처리
```cpp
void ChangeSize(GLsizei w, GLsizei h) {
    if (h == 0) h = 1;  // ==0으로 나누기 방지==

    glViewport(0, 0, w, h);         // **뷰포트 설정**
    glMatrixMode(GL_PROJECTION);     // **투영 행렬 모드**
    glLoadIdentity();                // 행렬 초기화

    GLfloat aspectRatio = (GLfloat)w / (GLfloat)h;

    // ==종횡비에 따른 좌표계 설정==
    if (w <= h) {
        glOrtho(-100, 100, -100/aspectRatio, 100/aspectRatio, -100, 100);
    } else {
        glOrtho(-100*aspectRatio, 100*aspectRatio, -100, 100, -100, 100);
    }

    glMatrixMode(GL_MODELVIEW);      // **모델뷰 행렬 모드**
    glLoadIdentity();
}
```

**코드 위치**: code/2-2-3.cpp:33-58

- `glViewport`는 실제 픽셀 영역을 다시 매핑하므로, **창 크기를 바꿀 때마다 호출**해 주어야 한다.
- `glMatrixMode(GL_PROJECTION)` 뒤에는 반드시 `glLoadIdentity()`로 기존 행렬을 지워야 한다. 그렇지 않으면 이전 프레임의 투영행렬이 누적되어 비정상적인 스케일 변화가 발생한다.
- `aspectRatio` 기반 분기문은 시험 문제에서 **빈칸 채우기** 형태로 나오기 쉬우므로, 조건과 결과를 세트로 기억한다.

#### 이벤트 루프 호출 흐름 요약

1. 프로그램 시작 시 main에서 초기화 후 `glutMainLoop()` 진입
2. 창이 처음 표시될 때 `RenderScene()`이 호출되어 첫 화면을 그림
3. 창 크기를 조정하면 OS가 `ChangeSize()`를 호출 → 내부에서 투영 행렬 재설정
4. 다시 그리기가 필요하면 `RenderScene()`이 호출되어 새 프레임을 렌더링

> **서술형 대비 TIP**: "이벤트 루프란 무엇인가?" → **OS 이벤트가 발생할 때마다 등록된 콜백이 호출되는 구조**임을 설명하고, 대표 콜백 2~3개를 함께 언급한다.

---

## 좌표계와 투영 (Projection)

OpenGL에서는 **여러 단계의 좌표계**를 거쳐 최종 픽셀 위치가 결정됩니다. 시험 문제는 대개 “어느 좌표계에서 값이 잘못 설정되었을 때 어떤 현상이 발생하는가?”를 묻거나, 특정 함수가 어느 단계에 영향을 주는지를 구분하도록 만듭니다. 아래 핵심 개념을 순서대로 이해해 두면 서술형·객관식 모두에 대응할 수 있습니다.

1. **모델 좌표(Model)**: 객체 자체의 로컬 좌표. 예: 삼각형을 정의할 때 사용.
2. **월드/카메라 좌표(ModelView)**: `glMatrixMode(GL_MODELVIEW)` 상태에서 변환이 적용되는 단계.
3. **투영 좌표(Projection)**: `glOrtho`, `gluPerspective` 등으로 시야 부피를 정의.
4. **정규 장치 좌표(NDC)**: -1~1 범위로 정규화된 공간.
5. **윈도우 좌표(Viewport 변환)**: 실제 픽셀 좌표. 디스플레이에 뿌려진다.

> ✅ **흔한 출제 포인트**: “viewport는 좌표계를 만든다(O/X)?” → X. viewport는 **NDC를 픽셀로 변환**할 뿐, 좌표계 범위는 Projection에서 정의한다.

### ==glViewport vs glOrtho==

| 함수 | 역할 | 파라미터 |
|------|------|----------|
| **glViewport(x, y, w, h)** | ==화면의 픽셀 영역 지정== | 픽셀 단위 좌표 |
| **glOrtho(left, right, bottom, top, near, far)** | ==논리 좌표계 범위 지정== | 가상 좌표 단위 |

두 함수를 헷갈리기 쉬운데, 기억법은 다음과 같습니다.

- `glViewport`: **모니터(출력기)** 입장에서 “내가 어느 범위에 그릴까?”를 정하는 단계.
- `glOrtho`: **카메라** 입장에서 “어떤 범위를 바라볼까?”를 정하는 단계.
- viewport를 바꾸어도 `glOrtho`를 유지하면 **보이는 범위는 동일하지만 픽셀 비율**이 바뀐다. 반대로 `glOrtho`를 바꾸면 보이는 범위가 달라져 스케일이 변한다.

### ==중요: zNear/zFar 범위==

```cpp
// ❌ 잘못된 예: z=50인 점이 안 보임
glOrtho(-100, 100, -100, 100, -1, 1);

// ✅ 올바른 예: z 범위를 충분히 확보
glOrtho(-100, 100, -100, 100, -100, 100);
```

**코드 위치**: code/3-1.cpp:47-52

> **시험 포인트**: z 좌표가 `zNear`와 `zFar` 범위 밖이면 ==클리핑되어 보이지 않음==
>
> - `zNear`, `zFar` 값은 **음수가 될 수 있음** (오르소그래픽 투영에서는 허용).
> - 값의 순서에 유의: `glOrtho(left, right, bottom, top, zNear, zFar)` → 마지막 두 인자가 거리 범위다.
> - 뷰 부피는 **카메라가 바라보는 박스 형태**라고 상상할 것. 박스 바깥의 물체는 잘린다.

💡 **추가 예제**  
`glOrtho(-2, 2, -2, 2, -2, 2)`로 설정하고 z=3에 물체를 두면 보이지 않음. 이유를 서술할 때는 “투영 볼륨 밖에 있으므로 클리핑된다”까지 써 주면 가산점을 받을 수 있다.

### ==행렬 모드 전환==

```cpp
glMatrixMode(GL_PROJECTION);   // **투영 행렬 수정**
glLoadIdentity();              // 현재 행렬 초기화

glMatrixMode(GL_MODELVIEW);    // **모델뷰 행렬로 복귀**
glLoadIdentity();
```

**코드 위치**: code/view(2-2-2).cpp:16-25

> **주의**: 행렬 모드를 바꾼 후 반드시 ==원래 모드로 복귀== 필요

### ==Projection 종류 비교==

| 구분 | Orthographic (`glOrtho`) | Perspective (`gluPerspective`) |
|------|-------------------------|--------------------------------|
| 특징 | 평행 투영, 거리와 관계없이 크기 동일 | 원근 투영, 카메라에서 멀수록 작아짐 |
| 사용 예 | 2D UI, CAD, 단순 그래프 | 3D 게임, 실사 렌더링 |
| 시험 포인트 | near/far 범위를 음수·양수 모두 사용 가능 | `gluPerspective(fov, aspect, near, far)` 형태 암기 |

> 현재 실습 코드는 모두 `glOrtho`를 사용하지만, **perspective로 전환할 때 바뀌는 인자**를 비교해 두면 확장 서술 문제에 대응할 수 있다.

---

## 종횡비 (Aspect Ratio) 문제

종횡비(aspect ratio)는 **가로/세로 비율**을 의미하며, OpenGL에서는 viewport와 투영 범위가 동시에 맞춰져야 화면이 찌그러지지 않습니다. 시험에서는 “왜 사각형이 직사각형으로 보이는가?”, “ChangeSize에서 어떤 분기를 추가해야 하는가?” 같은 상황형 문제가 출제됩니다. 문제를 풀 때는 **① 현재 viewport, ② 현재 glOrtho 범위, ③ 창 크기**를 차례로 비교해 종횡비 불일치 여부를 판단하면 실수가 줄어듭니다.

### ==문제 상황: 고정 좌표계==

#### 실험 1: 고정 viewport + 고정 좌표계
```cpp
// 창 크기가 변해도 viewport와 좌표계가 고정
glViewport(0, 0, 680, 480);         // **고정 픽셀 크기**
glOrtho(-320, 320, -240, 240, -1, 1); // **고정 논리 좌표**

glRectf(0, 240, 320, 0);  // 정사각형 그려도 ==찌그러짐==
```

**코드 위치**: code/quiz.cpp:19-28

**결과**: 창 크기를 바꾸면 ==사각형이 왜곡됨==

#### 실험 2: 500x500 고정 좌표계
```cpp
glViewport(0, 0, 500, 500);
glOrtho(0, 500, 0, 500, -1, 1);  // 500x500 정사각형 좌표계

// 창이 640x480이어도 좌표계는 500x500
glutInitWindowSize(640, 480);
```

**코드 위치**: code/quiz2.cpp:24-28

**결과**: ==픽셀 종횡비와 좌표계 종횡비 불일치== → 왜곡

### ==해결책: 동적 종횡비 조정==

```cpp
void ChangeSize(GLsizei w, GLsizei h) {
    glViewport(0, 0, w, h);  // **창 크기에 맞춰 viewport 변경**

    GLfloat aspectRatio = (GLfloat)w / (GLfloat)h;

    // **종횡비에 따라 좌표계 조정**
    if (w <= h) {
        // 세로가 더 길 때: y축 확장
        glOrtho(-100, 100, -100/aspectRatio, 100/aspectRatio, -100, 100);
    } else {
        // 가로가 더 길 때: x축 확장
        glOrtho(-100*aspectRatio, 100*aspectRatio, -100, 100, -100, 100);
    }
}
```

**코드 위치**: code/2-2-3.cpp:33-58

> **시험 포인트**:
> - `w <= h`: ==y축 범위를 aspectRatio로 나눔==
> - `w > h`: ==x축 범위를 aspectRatio로 곱함==
> - 목적: **정사각형이 항상 정사각형으로 보이게**

### ==Aspect Ratio 계산 절차==

1. **현재 창 크기 확인**: `w`, `h` 값으로 실제 종횡비 `w/h` 계산.
2. **원하는 가상 좌표 범위 결정**: 정사각형을 유지하려면 기본 범위를 `[-L, L]`으로 가정.
3. **조건 분기**  
   - `w <= h`: 가로보다 세로가 길다 → y 범위를 `L / aspect`, `-L / aspect`로 축소.
   - `w > h`: 가로가 더 길다 → x 범위를 `L * aspect`, `-L * aspect`로 확대.
4. **행렬 모드 복귀**: 프로젝션 변경 후 반드시 `MODELVIEW`로 되돌리기.

> **실수 방지**: aspectRatio를 float로 계산하는지 확인 (`(float)w / (float)h`). 정수 나눗셈이면 항상 0이 나와 좌표계가 붕괴한다.

### ==오답 노트 예시==

- `glViewport(0, 0, 500, 500)`을 고정한 상태에서 창 크기만 바꾸면? → **viewport는 그대로**, 빈 공간(letter box)이 생길 수 있다.
- aspectRatio 분기에서 `h <= 0`을 체크하지 않으면? → 창 높이가 0일 때 **나눗셈 예외** 발생.
- 모델뷰 행렬에서 스케일을 조절해 종횡비를 맞추려고 했다? → **Projection 단계에서 해결**해야 하는 문제이므로 틀린 접근.

---

## 기본 도형 그리기

실습에서는 OpenGL의 **Immediate Mode**(`glBegin`/`glEnd`)를 사용합니다. 비록 최신 OpenGL에서는 사용 빈도가 낮지만, **그래픽스 입문 수업과 시험**에서는 여전히 기본 개념을 설명하기 위한 표준입니다. 핵심은 “어떤 프리미티브 모드를 선택하면 정점이 어떻게 연결되는가?”를 정확히 이해하는 것입니다.

> ✅ **기억할 것**: `glBegin` 안에서 호출한 `glVertex*`는 선언 순서를 그대로 사용한다. 프리미티브 모드에 따라 두 개씩, 세 개씩 묶여 화면에 출력된다.

### ==GL_POINTS - 점 그리기==

#### 단일 점
```cpp
glColor3f(1.0f, 0.0f, 0.0f);  // 빨간색
glPointSize(8.0f);             // **점 크기 설정**

glBegin(GL_POINTS);
    glVertex3f(0.0f, 0.0f, 0.0f);      // (0,0,0) 점
    glVertex3f(50.0f, 50.0f, 50.0f);   // (50,50,50) 점
glEnd();
```

**코드 위치**: code/3-1.cpp:20-23

- `glPointSize`는 픽셀 단위로 점의 크기를 조절하며, 일부 플랫폼에서는 1보다 큰 값이 제한될 수 있다.
- 색상, 굵기, 점 크기 등 상태(state)는 **글로벌 상태**라서, 다음 도형에도 그대로 적용된다. 다른 색상을 쓰려면 `glColor3f`를 다시 호출.

#### 반복문으로 여러 점
```cpp
glBegin(GL_POINTS);
for (int i = 0; i <= 20; ++i) {
    float t = i / 20.0f;  // ==0.0 ~ 1.0 보간==
    glVertex3f(50 * t, 50 * t, 50 * t);  // 직선상 점들
}
glEnd();
```

**코드 위치**: code/3-1-1.cpp:21-25

### ==삼각함수로 원 그리기==

```cpp
glBegin(GL_POINTS);
for (float alpha = 0; alpha < 2 * 3.14f; alpha += 0.5f) {
    float x = 10.0f * cos(alpha);  // **원의 x 좌표**
    float y = 10.0f * sin(alpha);  // **원의 y 좌표**
    float z = 0.0f;
    glVertex3f(x, y, z);
}
glEnd();
```

**코드 위치**: code/3-1-1-a.cpp:22-28

> **시험 포인트**:
> - 반지름 r, 각도 α일 때: `x = r·cos(α)`, `y = r·sin(α)`
> - ==alpha 증가량이 작을수록 매끄러운 원==

### ==다른 프리미티브 한눈에 보기==

| 모드 | 정점 묶음 | 특징 | 활용 예 |
|------|-----------|------|---------|
| `GL_POINTS` | 1개씩 독립 | 점만 출력, 연결 없음 | 별자리 시각화 |
| `GL_LINES` | 2개씩 연결 | 각 두 정점마다 선분 | 좌표축, 와이어프레임 |
| `GL_LINE_LOOP` | 모든 정점 연결 후 시작점과 폐합 | 마지막 정점과 첫 정점을 자동 연결 | 다각형 외곽선 |
| `GL_TRIANGLES` | 3개씩 묶어 삼각형 | 면을 만들 때 기본 단위 | 메시 구성 |

> **기출**: “`GL_LINE_STRIP`과 `GL_LINE_LOOP`의 차이는?” → strip은 마지막과 처음을 연결하지 않음, loop는 연결함.

### ==glRectf - 사각형 그리기==

```cpp
glColor3f(1.0f, 0.0f, 0.0f);
glRectf(-50.0f, -50.0f, 50.0f, 50.0f);  // (x1, y1, x2, x2)
```

**코드 위치**: code/2-2-3.cpp:23

**파라미터**: `glRectf(x1, y1, x2, y2)` - ==대각선 반대편 두 점==

#### glRectf를 사용할 때 체크할 것

- 사각형은 `x1 < x2`, `y1 < y2`일 필요는 없지만, 좌표를 뒤바꾸면 **화면에 뒤집혀 보이거나** 방향을 헷갈릴 수 있다.
- `glRectf`는 **내부적으로 GL_QUADS를 사용**하므로, `glBegin(GL_QUADS)`로 직접 그리는 것과 동일한 결과를 제공한다.
- 투영 범위를 넘어선 좌표를 주면 **사각형 일부 또는 전체가 클리핑**된다. 시험에서 “왜 사각형이 반만 보이나?”를 묻는 문제는 대부분 이 때문.

---

## 주요 함수 정리

아래 함수들은 모든 예제에서 반복적으로 등장하며, **생략했을 때 어떤 문제가 생기는지**까지 이해해야 시험에서 응용 문제를 풀 수 있습니다. 단순 암기보다는 “호출 목적 → 생략 시 증상”을 짝지어 기억하면 효과적입니다.

### ==색상 및 속성==

```cpp
glClearColor(r, g, b, a);   // **배경색 설정**
glColor3f(r, g, b);         // **그리기 색상 설정** (0.0~1.0)
glPointSize(size);          // 점 크기 (픽셀)
```

- `glClearColor`는 `glClear`가 호출될 때 적용되므로, **RenderScene의 첫 호출 전에** 원하는 배경색을 정해 둔다.
- 알파 값(`a`)은 기본 실습에서는 눈에 보이지 않지만, 후에 blending을 사용할 때 중요해진다.
- `glColor3f`는 RGB 정규화 값(0~1)을 받는다. 정수 색상 값(0~255)을 넣으려면 `glColor3ub` 등을 써야 한다.

### ==버퍼 및 렌더링==

```cpp
glClear(GL_COLOR_BUFFER_BIT);  // ==화면 지우기 (매 프레임 필수)==
glFlush();                      // ==명령 즉시 실행==
```

- `glClear`의 인자로 `GL_DEPTH_BUFFER_BIT` 등을 추가하면 깊이버퍼까지 초기화할 수 있다. 시험에서 “깊이버퍼를 초기화하지 않았을 때 발생하는 현상”을 물으면 **이전 프레임의 깊이 정보로 인해 일부 픽셀이 그려지지 않는다**고 답변.
- 이중 버퍼 모드(`GLUT_DOUBLE`)에서는 `glFlush` 대신 `glutSwapBuffers()` 호출이 필수. 한 줄 누락 문제로 자주 나온다.

### ==GLUT 디스플레이 모드==

```cpp
GLUT_SINGLE   // 단일 버퍼
GLUT_DOUBLE   // 이중 버퍼 (애니메이션용)
GLUT_RGB      // **RGB 컬러 모드**
```

**코드 위치**: 모든 파일의 glutInitDisplayMode()

- `GLUT_DEPTH`, `GLUT_ALPHA` 등을 추가하면 해당 버퍼가 생성된다. 시험에서 “깊이버퍼를 사용하려면 어떤 플래그를 추가해야 하는가?” → `GLUT_DEPTH`.
- 디버깅 시 버퍼 모드를 바꿨는데 화면이 안 나오면, 콜백 내부에서 `glutSwapBuffers()` 호출 여부를 반드시 확인.

### ==좌표 변환 순서==

```
정점 좌표 → **MODELVIEW 행렬** → **PROJECTION 행렬** → **VIEWPORT 변환** → 화면 픽셀
```

> **시험 포인트**: ==변환 순서를 거꾸로 적용== (코드에서는 PROJECTION 먼저 설정)
>
> - 실제로는 행렬이 **우측에서 좌측 방향으로 곱해지므로**, 마지막에 설정한 행렬이 먼저 적용되는 것처럼 보인다.
> - 면접형 서술 문제 예시: “정점이 화면 픽셀에 도달하기까지 거치는 좌표계를 말하라” → 모델 → 월드/뷰 → 클립 → NDC → viewport 순으로 서술.

---

## 시험 빈출 문제

### 1. **고정 좌표계 문제**
Q: `glViewport(0,0,680,480)`와 `glOrtho(0,640,0,480,-1,1)`를 고정했을 때, 창 크기를 800x600으로 바꾸면?

A: ==사각형이 왜곡됨==. viewport는 픽셀 영역, ortho는 논리 좌표계이므로 **종횡비 불일치** 발생.

- **풀이 흐름**  
  1. viewport는 680x480으로 고정 → 종횡비 1.416.  
  2. 새 창은 800x600 → 종횡비 1.333.  
  3. 논리 좌표계는 640x480으로 종횡비 1.333.  
  4. viewport와 창 비율이 다르므로 출력이 늘어나거나 줄어들어 사각형이 찌그러짐.
- **답안 작성 팁**: “픽셀 변환 단계(viewport)와 논리 좌표계(projection)가 서로 다른 종횡비를 유지해서 시각적 왜곡이 발생한다”고 서술.

**참고**: code/quiz.cpp, code/quiz2.cpp

### 2. **zNear/zFar 클리핑**
Q: `glOrtho(-100, 100, -100, 100, -1, 1)`에서 z=50인 점이 안 보이는 이유?

A: ==z=50이 zFar=1 범위를 벗어남==. `glOrtho(..., -100, 100)`처럼 범위 확장 필요.

- **추가 설명**: 투영 부피는 `[-100, 100] x [-100, 100] x [-1, 1]` 박스 형태다. z=50은 이 박스 밖이므로 클리핑된다.
- **연관 질문**: “zNear를 0보다 크게 설정해야 하는가?” → 오르소그래픽에서는 필수는 아니지만, **perspective에서는 0을 사용할 수 없다**는 점을 덧붙이면 가산점.

**참고**: code/3-1.cpp:47-52

### 3. **종횡비 보정 공식**
Q: 창이 800x600일 때, 정사각형을 유지하려면 glOrtho를 어떻게?

A: aspectRatio = 800/600 = 1.333...
```cpp
// w > h 이므로
glOrtho(-100*1.333, 100*1.333, -100, 100, -100, 100);
```

- **풀이 흐름**  
  1. 기본 정사각형 범위를 `[-100, 100]`이라 가정.  
  2. 가로가 더 길기 때문에 x축 범위를 aspectRatio만큼 확대.  
  3. y 범위는 그대로 유지 → 화면에서 정사각형 유지.
- **기억법**: “w가 크면 x 확대, h가 크면 y 축소”.

**참고**: code/2-2-3.cpp:48-54

### 4. **원 그리기**
Q: 반지름 20, 각도 간격 0.1로 원을 그릴 때 코드는?

A:
```cpp
for (float alpha = 0; alpha < 2*3.14; alpha += 0.1) {
    glVertex3f(20*cos(alpha), 20*sin(alpha), 0);
}
```

- **확장 포인트**: 동일한 루프를 `GL_LINE_LOOP`에 사용하면 연속된 선으로 원을 그릴 수 있다.
- **각도 증가량**은 곧 샘플링 밀도이므로, `0.1 → 0.01`로 줄이면 더 부드럽지만 루프 횟수가 증가한다는 점을 언급.

**참고**: code/3-1-1-a.cpp:22-28

### 5. **행렬 모드와 초기화**
Q: ChangeSize에서 `glMatrixMode(GL_PROJECTION)`만 호출하고 `glLoadIdentity()`를 생략하면?

A: 이전 프레임의 투영 행렬이 누적되어 **스케일·이동 값이 쌓이며 화면이 왜곡**된다. 반복 실행 시 좌표가 급격하게 커지거나 작아지는 현상이 발생한다.

- **답안 팁**: “OpenGL 행렬은 상태가 누적되는 구조(state machine)”라는 표현을 써 주면 채점자가 의도를 파악하기 쉽다.

### 6. **디스플레이/리사이즈 콜백 순서**
Q: 프로그램 실행 직후 어떤 콜백이 호출되는가?

A: 창 생성 직후 운영체제가 크기 조정을 요청하므로 `ChangeSize`가 먼저 호출되고, 이어서 `RenderScene`이 호출된다. 콜백 등록이 누락되면 해당 이벤트가 발생해도 아무런 동작이 없다.

- **추가 설명**: 이 순서를 기억하면 “첫 렌더링에서 왜 화면이 비어 있나?” 같은 질문에 답할 수 있다.

---

## 코드별 학습 포인트

| 파일명 | 핵심 개념 | 시험 중요도 |
|--------|----------|------------|
| 3-1.cpp | ==두 점 그리기, zNear/zFar== | ⭐⭐⭐ |
| 3-1-1.cpp | ==반복문으로 직선 점 찍기== | ⭐⭐ |
| 3-1-1-a.cpp | ==삼각함수로 원 그리기== | ⭐⭐⭐ |
| 2-2-3.cpp | ==동적 종횡비 조정== | ⭐⭐⭐⭐⭐ |
| view(2-2-2).cpp | ==고정 좌표계 왜곡 실험== | ⭐⭐⭐⭐ |
| quiz.cpp | ==viewport/ortho 고정 (680x480)== | ⭐⭐⭐⭐ |
| quiz2.cpp | ==viewport/ortho 고정 (500x500)== | ⭐⭐⭐⭐ |

---

## 실습 팁

1. **항상 먼저 체크**: `glClear()` 호출 확인
2. **행렬 모드**: PROJECTION 수정 후 ==MODELVIEW로 복귀==
3. **종횡비**: `w <= h`와 `w > h` 케이스 분리
4. **z 범위**: 3D 점 사용 시 ==zNear/zFar 충분히 확보==
5. **디버깅**: 점이 안 보이면 glPointSize() 확인

---

## 서술형 · 면접형 답안 예시

- “OpenGL에서 이벤트 루프는 `glutMainLoop`가 운영체제 이벤트를 받아 등록된 콜백을 호출하는 구조이며, 창 생성 직후 `ChangeSize`, 이어서 `RenderScene`이 순차적으로 호출된다.”
- “`glViewport`는 정규 장치 좌표(-1~1)를 실제 픽셀 좌표로 변환하는 단계이기 때문에, 창 크기가 변하면 projection과 함께 재설정하여 종횡비를 맞춰야 한다.”
- “오르소그래픽 투영에서 `zNear`, `zFar`는 시야 상자의 깊이를 정하므로, 범위를 벗어난 정점은 클리핑되어 화면에 나타나지 않는다.”
- “Immediate Mode의 상태 머신 특성상, `glColor3f` 등으로 설정한 값은 다음 primitive에도 영향을 주므로 필요하면 매번 명시적으로 값을 지정해야 한다.”

---

## 학습 로드맵 제안

1. **기본 구조 암기**  
   - main → 콜백 등록 → `glutMainLoop` → 콜백 흐름을 그림으로 정리.
2. **좌표계 실습**  
   - `glOrtho` 값만 바꾸어 보며 무엇이 변하는지 로그를 남기기.
3. **종횡비 실험**  
   - `ChangeSize` 조건문을 주석 처리해보고 왜곡 사례를 스크린샷으로 기록.
4. **프리미티브 변형**  
   - 같은 정점 데이터를 `GL_POINTS`, `GL_LINES`, `GL_TRIANGLES`로 각각 렌더링.
5. **모의고사 작성**  
   - 위 빈출 문제를 기반으로 직접 서술형 답안을 작성해 보고, 수업 노트와 비교.

> **공부 팁**: 각 단계에서 “이 함수를 빼면 어떤 버그가 생기나?”를 스스로 설명할 수 있을 때까지 반복하면 시험장에서도 응용 문제를 빠르게 해결할 수 있습니다.

---

**마지막 업데이트**: 2025-02-14
